venv\Scripts\activate

import os
import logging
import requests
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler
from telegram.error import TelegramError
import yt_dlp
import asyncio
from dotenv import load_dotenv
import re
import subprocess
import glob
import json
from datetime import datetime

# ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ù…Ù† Ù…Ù„Ù .env
load_dotenv()

# Ø¥Ø¹Ø¯Ø§Ø¯ Ù†Ø¸Ø§Ù… Ø§Ù„Ø³Ø¬Ù„Ø§Øª
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Ø¬Ù„Ø¨ Ø§Ù„ØªÙˆÙƒÙ† Ù…Ù† Ù…Ù„Ù .env
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")

# Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„ØªÙˆÙƒÙ†
if not TELEGRAM_BOT_TOKEN:
    logger.error("âŒ Ø®Ø·Ø£: Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ TELEGRAM_BOT_TOKEN ÙÙŠ Ù…Ù„Ù .env")
    exit(1)

# Ù…Ø¹Ø±Ù Ø§Ù„Ù‚Ù†Ø§Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ù‡Ø§ (Ø¨Ø¯ÙˆÙ† @)
REQUIRED_CHANNEL = os.getenv("REQUIRED_CHANNEL", "sakerrr77")
CHANNEL_LINK = os.getenv("CHANNEL_LINK", "https://t.me/sakerrr77")

# Ù…Ø¬Ù„Ø¯ Ù…Ø¤Ù‚Øª Ù„Ù„ØªØ­Ù…ÙŠÙ„Ø§Øª
DOWNLOAD_FOLDER = "downloads"
os.makedirs(DOWNLOAD_FOLDER, exist_ok=True)

# Ù…Ù„Ù Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
STATS_FILE = "bot_stats.json"

# Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ø·ÙˆØ± (Ø¶Ø¹ Ù…Ø¹Ø±ÙÙƒ Ù‡Ù†Ø§)
DEVELOPER_ID = int(os.getenv("DEVELOPER_ID", "0"))  # Ø¶Ø¹ Ù…Ø¹Ø±ÙÙƒ ÙÙŠ .env

# ØªØ®Ø²ÙŠÙ† Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (Ù†ÙˆØ¹ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨)
user_states = {}
# ØªØ®Ø²ÙŠÙ† Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø«
search_results = {}

# Ù†Ø¸Ø§Ù… Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
class BotStats:
    def __init__(self):
        self.stats_file = STATS_FILE
        self.load_stats()
    
    def load_stats(self):
        """ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…Ù† Ø§Ù„Ù…Ù„Ù"""
        if os.path.exists(self.stats_file):
            try:
                with open(self.stats_file, 'r', encoding='utf-8') as f:
                    self.data = json.load(f)
            except:
                self.data = self.create_new_stats()
        else:
            self.data = self.create_new_stats()
    
    def create_new_stats(self):
        """Ø¥Ù†Ø´Ø§Ø¡ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø¬Ø¯ÙŠØ¯Ø©"""
        return {
            'total_users': 0,
            'users': {},  # {user_id: {name, username, first_seen, last_seen, usage_count}}
            'total_downloads': 0,
            'downloads_by_type': {
                'image': 0,
                'video': 0,
                'audio': 0,
                'search': 0
            },
            'total_searches': 0,
            'failed_downloads': 0,
            'start_date': datetime.now().isoformat()
        }
    
    def save_stats(self):
        """Ø­ÙØ¸ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø¥Ù„Ù‰ Ø§Ù„Ù…Ù„Ù"""
        try:
            with open(self.stats_file, 'w', encoding='utf-8') as f:
                json.dump(self.data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª: {e}")
    
    def add_user(self, user_id, name, username):
        """Ø¥Ø¶Ø§ÙØ© Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯"""
        user_id_str = str(user_id)
        now = datetime.now().isoformat()
        
        if user_id_str not in self.data['users']:
            self.data['total_users'] += 1
            self.data['users'][user_id_str] = {
                'name': name,
                'username': username,
                'first_seen': now,
                'last_seen': now,
                'usage_count': 1
            }
        else:
            self.data['users'][user_id_str]['last_seen'] = now
            self.data['users'][user_id_str]['usage_count'] += 1
        
        self.save_stats()
    
    def add_download(self, download_type):
        """ØªØ³Ø¬ÙŠÙ„ ØªØ­Ù…ÙŠÙ„"""
        self.data['total_downloads'] += 1
        if download_type in self.data['downloads_by_type']:
            self.data['downloads_by_type'][download_type] += 1
        self.save_stats()
    
    def add_search(self):
        """ØªØ³Ø¬ÙŠÙ„ Ø¨Ø­Ø«"""
        self.data['total_searches'] += 1
        self.save_stats()
    
    def add_failed_download(self):
        """ØªØ³Ø¬ÙŠÙ„ ØªØ­Ù…ÙŠÙ„ ÙØ§Ø´Ù„"""
        self.data['failed_downloads'] += 1
        self.save_stats()
    
    def get_stats_text(self):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù†Øµ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª"""
        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù†Ø´Ø·ÙŠÙ† (Ø§Ø³ØªØ®Ø¯Ù…ÙˆØ§ Ø§Ù„Ø¨ÙˆØª ÙÙŠ Ø¢Ø®Ø± 24 Ø³Ø§Ø¹Ø©)
        from datetime import datetime, timedelta
        now = datetime.now()
        active_users = 0
        
        for user_data in self.data['users'].values():
            last_seen = datetime.fromisoformat(user_data['last_seen'])
            if (now - last_seen).days == 0:
                active_users += 1
        
        # Ø£ÙƒØ«Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù†Ø´Ø§Ø·Ø§Ù‹
        top_users = sorted(
            self.data['users'].items(),
            key=lambda x: x[1]['usage_count'],
            reverse=True
        )[:5]
        
        top_users_text = "\n".join([
            f"  {i+1}. {user[1]['name']} (@{user[1]['username']}) - {user[1]['usage_count']} Ø§Ø³ØªØ®Ø¯Ø§Ù…"
            for i, user in enumerate(top_users)
        ])
        
        stats_text = f"""
ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª Ø§Ù„Ø´Ø§Ù…Ù„Ø©

ğŸ‘¥ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†:
â€¢ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: {self.data['total_users']}
â€¢ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù†Ø´Ø·ÙŠÙ† Ø§Ù„ÙŠÙˆÙ…: {active_users}

ğŸ“¥ Ø§Ù„ØªØ­Ù…ÙŠÙ„Ø§Øª:
â€¢ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„Ø§Øª: {self.data['total_downloads']}
  - ØµÙˆØ±: {self.data['downloads_by_type']['image']}
  - ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª: {self.data['downloads_by_type']['video']}
  - Ù…ÙˆØ³ÙŠÙ‚Ù‰: {self.data['downloads_by_type']['audio']}
  - Ø£ØºØ§Ù†ÙŠ (Ø¨Ø­Ø«): {self.data['downloads_by_type']['search']}

ğŸ” Ø§Ù„Ø¨Ø­Ø«:
â€¢ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ø¨Ø­Ø«: {self.data['total_searches']}

âŒ Ø§Ù„ÙØ´Ù„:
â€¢ Ø§Ù„ØªØ­Ù…ÙŠÙ„Ø§Øª Ø§Ù„ÙØ§Ø´Ù„Ø©: {self.data['failed_downloads']}

ğŸ† Ø£ÙƒØ«Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù†Ø´Ø§Ø·Ø§Ù‹:
{top_users_text if top_users_text else "  Ù„Ø§ ÙŠÙˆØ¬Ø¯"}

ğŸ“… ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¨Ø¯Ø¡: {self.data['start_date'][:10]}
        """
        
        return stats_text

# Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ§Ø¦Ù† Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
stats = BotStats()

class SocialMediaDownloader:
    """ÙØ¦Ø© Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ù…Ù† Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„ØªÙˆØ§ØµÙ„ Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠ"""
    
    def __init__(self):
        # Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
        self.ydl_opts_video = {
            'format': 'best[ext=mp4]/best',
            'outtmpl': f'{DOWNLOAD_FOLDER}/%(title)s.%(ext)s',
            'quiet': False,
            'no_warnings': False,
            'nocheckcertificate': True,
            'prefer_ffmpeg': True,
            'merge_output_format': 'mp4',
        }
        
        # Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØª
        self.ydl_opts_audio = {
            'format': 'bestaudio/best',
            'outtmpl': f'{DOWNLOAD_FOLDER}/%(title)s.%(ext)s',
            'postprocessors': [{
                'key': 'FFmpegExtractAudio',
                'preferredcodec': 'mp3',
                'preferredquality': '192',
            }],
            'quiet': False,
            'nocheckcertificate': True,
        }
    
    def download_image(self, url):
        """ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ù…Ù† Ø§Ù„Ø±Ø§Ø¨Ø· - Ù…Ø¹ Ø·Ø±Ù‚ Ù…ØªØ¹Ø¯Ø¯Ø©"""
        logger.info(f"Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ù…Ù†: {url}")
        
        # Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© 1: Instagram Ø£Ùˆ Ø£ÙŠ Ù…ÙˆÙ‚Ø¹ - Web Scraping
        try:
            logger.info("Ø§Ø³ØªØ®Ø¯Ø§Ù… Web Scraping...")
            return self._download_with_scraping(url)
        except Exception as e:
            logger.warning(f"ÙØ´Ù„ Web Scraping: {e}")
        
        # Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© 2: ØªØ­Ù…ÙŠÙ„ Ù…Ø¨Ø§Ø´Ø± (Ù„Ù„Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©)
        try:
            logger.info("Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±...")
            return self._download_direct(url)
        except Exception as e:
            logger.warning(f"ÙØ´Ù„ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±: {e}")
        
        # Ø¥Ø°Ø§ ÙØ´Ù„Øª ÙƒÙ„ Ø§Ù„Ø·Ø±Ù‚
        logger.error("ÙØ´Ù„Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø·Ø±Ù‚")
        raise Exception("ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©. ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø±Ø§Ø¨Ø· ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ ØµÙˆØ±Ø© Ø¹Ø§Ù…Ø©")
    
    def _download_instagram_image(self, url):
        """ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Instagram Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Web Scraping Ø§Ù„Ù…ØªÙ‚Ø¯Ù…"""
        try:
            logger.info("Ø§Ø³ØªØ®Ø¯Ø§Ù… Web Scraping Ù„Ù€ Instagram...")
            
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5',
                'Accept-Encoding': 'gzip, deflate, br',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1',
                'Sec-Fetch-Dest': 'document',
                'Sec-Fetch-Mode': 'navigate',
                'Sec-Fetch-Site': 'none',
                'Cache-Control': 'max-age=0',
            }
            
            # Ø¬Ù„Ø¨ Ø§Ù„ØµÙØ­Ø©
            logger.info(f"Ø¬Ù„Ø¨ ØµÙØ­Ø©: {url}")
            response = requests.get(url, headers=headers, timeout=30)
            response.raise_for_status()
            html = response.text
            
            logger.info(f"ØªÙ… Ø¬Ù„Ø¨ {len(html)} Ø­Ø±Ù Ù…Ù† HTML")
            
            # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØµÙˆØ± ÙÙŠ HTML
            image_patterns = [
                r'"display_url":"(https://[^"]+)"',  # Instagram display_url
                r'"display_src":"(https://[^"]+)"',  # Ø¨Ø¯ÙŠÙ„
                r'property="og:image" content="([^"]+)"',  # Open Graph
                r'"thumbnail_src":"(https://[^"]+)"',  # thumbnail
            ]
            
            image_url = None
            for pattern in image_patterns:
                matches = re.findall(pattern, html)
                if matches:
                    logger.info(f"ÙˆØ¬Ø¯Øª {len(matches)} ØªØ·Ø§Ø¨Ù‚Ø§Øª Ù„Ù„Ù†Ù…Ø·")
                    # Ø£Ø®Ø° Ø£ÙˆÙ„ Ø±Ø§Ø¨Ø· ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ cdninstagram (ØµÙˆØ± Instagram Ø§Ù„Ø£ØµÙ„ÙŠØ©)
                    for match in matches:
                        if 'cdninstagram' in match or 'fbcdn' in match:
                            image_url = match.replace('\\u0026', '&').replace('\\/', '/')
                            logger.info(f"ÙˆØ¬Ø¯Øª Ø±Ø§Ø¨Ø· ØµÙˆØ±Ø©: {image_url[:100]}...")
                            break
                    if image_url:
                        break
            
            if not image_url:
                raise Exception("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø© ÙÙŠ Ø§Ù„ØµÙØ­Ø©")
            
            # ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©
            logger.info("ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©...")
            img_response = requests.get(image_url, headers=headers, timeout=30)
            img_response.raise_for_status()
            
            logger.info(f"ØªÙ… ØªØ­Ù…ÙŠÙ„ {len(img_response.content)} Ø¨Ø§ÙŠØª")
            
            if len(img_response.content) == 0:
                raise Exception("Ù…Ø­ØªÙˆÙ‰ Ø§Ù„ØµÙˆØ±Ø© ÙØ§Ø±Øº")
            
            # Ø­ÙØ¸ Ø§Ù„ØµÙˆØ±Ø©
            filename = f"{DOWNLOAD_FOLDER}/instagram_{os.urandom(4).hex()}.jpg"
            
            with open(filename, 'wb') as f:
                f.write(img_response.content)
            
            # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­ÙØ¸
            if os.path.exists(filename):
                file_size = os.path.getsize(filename)
                logger.info(f"ØªÙ… Ø­ÙØ¸ Ø§Ù„ØµÙˆØ±Ø©: {filename} ({file_size} Ø¨Ø§ÙŠØª)")
                
                if file_size > 0:
                    return filename, "Instagram Image"
                else:
                    raise Exception("Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø­ÙÙˆØ¸ ÙØ§Ø±Øº")
            else:
                raise Exception("ÙØ´Ù„ Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù")
            
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ _download_instagram_image: {e}")
            raise Exception(f"ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Instagram: {str(e)}")
    
    def _download_with_gallery_dl(self, url):
        """ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… gallery-dl"""
        try:
            logger.info("Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… gallery-dl")
            
            cmd = [
                'gallery-dl',
                '--no-video',
                '-d', DOWNLOAD_FOLDER,
                url
            ]
            
            logger.info(f"ØªÙ†ÙÙŠØ° Ø§Ù„Ø£Ù…Ø±: {' '.join(cmd)}")
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            
            logger.info(f"gallery-dl stdout: {result.stdout}")
            logger.info(f"gallery-dl stderr: {result.stderr}")
            
            if result.returncode != 0:
                raise Exception(f"gallery-dl error code {result.returncode}")
            
            # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¢Ø®Ø± Ù…Ù„Ù ØµÙˆØ±Ø© ØªÙ… ØªØ­Ù…ÙŠÙ„Ù‡
            image_extensions = ['.jpg', '.jpeg', '.png', '.webp', '.gif']
            all_files = []
            
            for ext in image_extensions:
                all_files.extend(glob.glob(f"{DOWNLOAD_FOLDER}/*{ext}"))
            
            logger.info(f"Ù…Ù„ÙØ§Øª Ø§Ù„ØµÙˆØ± Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©: {all_files}")
            
            if all_files:
                latest_file = max(all_files, key=os.path.getctime)
                title = os.path.splitext(os.path.basename(latest_file))[0]
                logger.info(f"ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø§Ù„ØµÙˆØ±Ø©: {latest_file}")
                return latest_file, title
            
            raise Exception("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ØµÙˆØ±Ø© Ù…Ø­Ù…Ù„Ø©")
            
        except FileNotFoundError:
            raise Exception("gallery-dl ØºÙŠØ± Ù…Ø«Ø¨Øª. Ù†ÙØ°: pip install gallery-dl")
        except subprocess.TimeoutExpired:
            raise Exception("Ø§Ù†ØªÙ‡Øª Ù…Ù‡Ù„Ø© Ø§Ù„ØªØ­Ù…ÙŠÙ„")
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ _download_with_gallery_dl: {e}")
            raise Exception(f"Ø®Ø·Ø£ ÙÙŠ gallery-dl: {str(e)}")
    
    def _download_image_ytdlp(self, url):
        """ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… yt-dlp (Ù„Ù„ØµÙˆØ± ÙÙ‚Ø·)"""
        opts = {
            'format': 'best',
            'outtmpl': f'{DOWNLOAD_FOLDER}/%(id)s.%(ext)s',
            'quiet': True,
            'no_warnings': True,
            'nocheckcertificate': True,
        }
        
        with yt_dlp.YoutubeDL(opts) as ydl:
            info = ydl.extract_info(url, download=False)
            
            if not info:
                raise Exception("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª")
            
            # Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø©
            image_url = None
            
            if 'url' in info and info['url']:
                image_url = info['url']
            elif 'thumbnails' in info and info['thumbnails']:
                thumbnails = sorted(info['thumbnails'], 
                                  key=lambda x: (x.get('width', 0) * x.get('height', 0)), 
                                  reverse=True)
                image_url = thumbnails[0]['url']
            elif 'thumbnail' in info and info['thumbnail']:
                image_url = info['thumbnail']
            
            if not image_url:
                raise Exception("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· ØµÙˆØ±Ø©")
            
            # ØªØ­Ù…ÙŠÙ„ Ù…Ù† Ø§Ù„Ø±Ø§Ø¨Ø·
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            }
            
            response = requests.get(image_url, headers=headers, timeout=30)
            response.raise_for_status()
            
            # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§Ù…ØªØ¯Ø§Ø¯
            content_type = response.headers.get('content-type', '').lower()
            if 'jpeg' in content_type or 'jpg' in content_type:
                ext = 'jpg'
            elif 'png' in content_type:
                ext = 'png'
            elif 'gif' in content_type:
                ext = 'gif'
            elif 'webp' in content_type:
                ext = 'webp'
            else:
                ext = 'jpg'
            
            title = info.get('title', info.get('id', 'image'))
            safe_title = "".join(c for c in title if c.isalnum() or c in (' ', '-', '_'))[:50]
            if not safe_title:
                safe_title = info.get('id', 'image')
            
            filename = f"{DOWNLOAD_FOLDER}/{safe_title}.{ext}"
            
            with open(filename, 'wb') as f:
                f.write(response.content)
            
            return filename, title
    
    def _download_with_scraping(self, url):
        """ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Web Scraping"""
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
        }
        
        try:
            response = requests.get(url, headers=headers, timeout=30)
            response.raise_for_status()
            html = response.text
            
            # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØµÙˆØ± ÙÙŠ HTML
            image_patterns = [
                r'"display_url":"(https://[^"]+)"',  # Instagram
                r'property="og:image" content="([^"]+)"',  # Open Graph
                r'"contentUrl":"(https://[^"]+)"',  # Schema.org
                r'<img[^>]+src="([^"]+)"[^>]*>',  # IMG tags
            ]
            
            image_url = None
            for pattern in image_patterns:
                matches = re.findall(pattern, html)
                if matches:
                    # Ø£Ø®Ø° Ø£ÙˆÙ„ Ø±Ø§Ø¨Ø· ÙŠØ¨Ø¯Ùˆ Ø£Ù†Ù‡ ØµÙˆØ±Ø© Ø­Ù‚ÙŠÙ‚ÙŠØ©
                    for match in matches:
                        if any(ext in match.lower() for ext in ['.jpg', '.jpeg', '.png', '.webp']) or 'fbcdn' in match or 'cdninstagram' in match:
                            image_url = match.replace('\\u0026', '&')
                            break
                    if image_url:
                        break
            
            if not image_url:
                raise Exception("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· ØµÙˆØ±Ø© ÙÙŠ Ø§Ù„ØµÙØ­Ø©")
            
            logger.info(f"ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø©: {image_url[:100]}...")
            
            # ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©
            img_response = requests.get(image_url, headers=headers, timeout=30)
            img_response.raise_for_status()
            
            # Ø­ÙØ¸ Ø§Ù„ØµÙˆØ±Ø©
            content_type = img_response.headers.get('content-type', '').lower()
            if 'jpeg' in content_type or 'jpg' in content_type:
                ext = 'jpg'
            elif 'png' in content_type:
                ext = 'png'
            elif 'webp' in content_type:
                ext = 'webp'
            else:
                ext = 'jpg'
            
            filename = f"{DOWNLOAD_FOLDER}/scraped_image.{ext}"
            
            with open(filename, 'wb') as f:
                f.write(img_response.content)
            
            return filename, "ØµÙˆØ±Ø©"
            
        except Exception as e:
            raise Exception(f"ÙØ´Ù„ Web Scraping: {str(e)}")
    
    def _download_direct(self, url):
        """ØªØ­Ù…ÙŠÙ„ Ù…Ø¨Ø§Ø´Ø± Ù„Ù„Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©"""
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        
        response = requests.get(url, headers=headers, timeout=30)
        response.raise_for_status()
        
        # ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø§Ù…ØªØ¯Ø§Ø¯ Ù…Ù† content-type Ø£Ùˆ URL
        content_type = response.headers.get('content-type', '').lower()
        if 'jpeg' in content_type or 'jpg' in content_type:
            ext = 'jpg'
        elif 'png' in content_type:
            ext = 'png'
        elif 'gif' in content_type:
            ext = 'gif'
        elif 'webp' in content_type:
            ext = 'webp'
        elif 'image' in content_type:
            ext = 'jpg'
        else:
            # Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ù† URL
            ext = url.split('.')[-1].split('?')[0].lower()
            if ext not in ['jpg', 'jpeg', 'png', 'gif', 'webp']:
                ext = 'jpg'
        
        filename = f"{DOWNLOAD_FOLDER}/direct_image.{ext}"
        
        with open(filename, 'wb') as f:
            f.write(response.content)
        
        return filename, "ØµÙˆØ±Ø©"
    
    def download_video(self, url):
        """ØªØ­Ù…ÙŠÙ„ ÙÙŠØ¯ÙŠÙˆ Ù…Ù† Ø§Ù„Ø±Ø§Ø¨Ø·"""
        try:
            with yt_dlp.YoutubeDL(self.ydl_opts_video) as ydl:
                info = ydl.extract_info(url, download=True)
                filename = ydl.prepare_filename(info)
                
                # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ù„Ù Ø¨ØµÙŠØºØ© ØºÙŠØ± mp4ØŒ ØªØ­ÙˆÙŠÙ„Ù‡
                if not filename.endswith('.mp4'):
                    base = os.path.splitext(filename)[0]
                    new_filename = f"{base}.mp4"
                    if os.path.exists(new_filename):
                        filename = new_filename
                
                return filename, info.get('title', 'ÙÙŠØ¯ÙŠÙˆ')
        except Exception as e:
            raise Exception(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: {str(e)}")
    
    def download_audio(self, url):
        """ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØª Ù…Ù† Ø§Ù„Ø±Ø§Ø¨Ø·"""
        try:
            with yt_dlp.YoutubeDL(self.ydl_opts_audio) as ydl:
                info = ydl.extract_info(url, download=True)
                filename = ydl.prepare_filename(info)
                audio_filename = filename.rsplit('.', 1)[0] + '.mp3'
                
                if not os.path.exists(audio_filename):
                    base = os.path.splitext(filename)[0]
                    for ext in ['.mp3', '.m4a', '.opus', '.webm']:
                        test_file = f"{base}{ext}"
                        if os.path.exists(test_file):
                            audio_filename = test_file
                            break
                
                return audio_filename, info.get('title', 'ØµÙˆØª')
        except Exception as e:
            raise Exception(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØª: {str(e)}")
    
    def get_info(self, url):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…ÙØµÙ„Ø© Ø¹Ù† Ø§Ù„Ø±Ø§Ø¨Ø·"""
        try:
            opts = {
                'quiet': True, 
                'no_warnings': True,
                'nocheckcertificate': True,
                'extract_flat': False,
            }
            
            with yt_dlp.YoutubeDL(opts) as ydl:
                info = ydl.extract_info(url, download=False)
                
                if not info:
                    raise Exception("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª")
                
                return info
                
        except yt_dlp.utils.DownloadError as e:
            logger.error(f"Ø®Ø·Ø£ yt-dlp: {e}")
            raise Exception("Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø­ØªÙˆÙ‰")
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ Ø¹Ø§Ù… ÙÙŠ get_info: {e}")
            raise Exception(f"Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª: {str(e)}")
    
    def search_youtube(self, query, max_results=5):
        """Ø§Ù„Ø¨Ø­Ø« ÙÙŠ YouTube Ø¹Ù† Ø£ØºÙ†ÙŠØ©"""
        try:
            logger.info(f"Ø§Ù„Ø¨Ø­Ø« ÙÙŠ YouTube: {query}")
            
            ydl_opts = {
                'quiet': True,
                'no_warnings': True,
                'extract_flat': True,
                'nocheckcertificate': True,
            }
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                # Ø§Ù„Ø¨Ø­Ø« ÙÙŠ YouTube
                search_query = f"ytsearch{max_results}:{query}"
                result = ydl.extract_info(search_query, download=False)
                
                if not result or 'entries' not in result:
                    raise Exception("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬")
                
                videos = []
                for entry in result['entries']:
                    if entry:
                        videos.append({
                            'id': entry.get('id'),
                            'title': entry.get('title'),
                            'url': f"https://www.youtube.com/watch?v={entry.get('id')}",
                            'duration': entry.get('duration', 0),
                            'channel': entry.get('uploader', entry.get('channel', 'Unknown'))
                        })
                
                logger.info(f"ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ {len(videos)} Ù†ØªÙŠØ¬Ø©")
                return videos
                
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø«: {e}")
            raise Exception(f"ÙØ´Ù„ Ø§Ù„Ø¨Ø­Ø«: {str(e)}")
        """Ø§Ù„Ø¨Ø­Ø« ÙÙŠ YouTube Ø¹Ù† Ø£ØºÙ†ÙŠØ©"""
        try:
            logger.info(f"Ø§Ù„Ø¨Ø­Ø« ÙÙŠ YouTube: {query}")
            
            ydl_opts = {
                'quiet': True,
                'no_warnings': True,
                'extract_flat': True,
                'nocheckcertificate': True,
            }
            
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                # Ø§Ù„Ø¨Ø­Ø« ÙÙŠ YouTube
                search_query = f"ytsearch{max_results}:{query}"
                result = ydl.extract_info(search_query, download=False)
                
                if not result or 'entries' not in result:
                    raise Exception("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬")
                
                videos = []
                for entry in result['entries']:
                    if entry:
                        videos.append({
                            'id': entry.get('id'),
                            'title': entry.get('title'),
                            'url': f"https://www.youtube.com/watch?v={entry.get('id')}",
                            'duration': entry.get('duration', 0),
                            'channel': entry.get('uploader', entry.get('channel', 'Unknown'))
                        })
                
                logger.info(f"ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ {len(videos)} Ù†ØªÙŠØ¬Ø©")
                return videos
                
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø«: {e}")
            raise Exception(f"ÙØ´Ù„ Ø§Ù„Ø¨Ø­Ø«: {str(e)}")
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…ÙØµÙ„Ø© Ø¹Ù† Ø§Ù„Ø±Ø§Ø¨Ø·"""
        try:
            opts = {
                'quiet': True, 
                'no_warnings': True,
                'nocheckcertificate': True,
                'extract_flat': False,
            }
            
            with yt_dlp.YoutubeDL(opts) as ydl:
                info = ydl.extract_info(url, download=False)
                
                if not info:
                    raise Exception("Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª")
                
                return info
                
        except yt_dlp.utils.DownloadError as e:
            logger.error(f"Ø®Ø·Ø£ yt-dlp: {e}")
            raise Exception("Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø­ØªÙˆÙ‰")
        except Exception as e:
            logger.error(f"Ø®Ø·Ø£ Ø¹Ø§Ù… ÙÙŠ get_info: {e}")
            raise Exception(f"Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª: {str(e)}")

# Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ§Ø¦Ù† Ø§Ù„ØªØ­Ù…ÙŠÙ„
downloader = SocialMediaDownloader()

async def check_subscription(update: Update, context: ContextTypes.DEFAULT_TYPE) -> bool:
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©"""
    user_id = update.effective_user.id
    
    try:
        member = await context.bot.get_chat_member(chat_id=f"@{REQUIRED_CHANNEL}", user_id=user_id)
        if member.status in ['creator', 'administrator', 'member']:
            return True
        else:
            return False
    except TelegramError as e:
        logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ: {e}")
        return False

async def subscription_required(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø±Ø³Ø§Ù„Ø© Ø·Ù„Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©"""
    keyboard = [
        [InlineKeyboardButton("ğŸ“¢ Ø§Ø´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©", url=CHANNEL_LINK)],
        [InlineKeyboardButton("âœ… ØªØ­Ù‚Ù‚Øª Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ", callback_data="check_subscription")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    message = """
ğŸ”’ Ù„Ù„Ø§Ø³ØªÙØ§Ø¯Ø© Ù…Ù† Ø§Ù„Ø¨ÙˆØª ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ù‚Ù†Ø§ØªÙ†Ø§ Ø£ÙˆÙ„Ø§Ù‹!

ğŸ“¢ Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø± Ø£Ø¯Ù†Ø§Ù‡ Ù„Ù„Ø§Ø´ØªØ±Ø§Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©
Ø«Ù… Ø§Ø¶ØºØ· "âœ… ØªØ­Ù‚Ù‚Øª Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ"
    """
    
    if update.callback_query:
        await update.callback_query.message.edit_text(message, reply_markup=reply_markup)
    else:
        await update.message.reply_text(message, reply_markup=reply_markup)

async def check_subscription_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¹Ø¨Ø± Ø§Ù„Ø²Ø±"""
    query = update.callback_query
    await query.answer()
    
    if await check_subscription(update, context):
        await query.message.edit_text("âœ… Ø±Ø§Ø¦Ø¹! Ø£Ù†Øª Ù…Ø´ØªØ±Ùƒ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©\nÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª ğŸ‰\n\nØ£Ø±Ø³Ù„ /start Ù„Ø¨Ø¯Ø¡ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…")
    else:
        await subscription_required(update, context)

def get_type_selection_keyboard():
    """Ø¥Ù†Ø´Ø§Ø¡ Ù„ÙˆØ­Ø© Ù…ÙØ§ØªÙŠØ­ Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ù…Ø­ØªÙˆÙ‰"""
    keyboard = [
        [
            InlineKeyboardButton("ğŸ¬ ÙÙŠØ¯ÙŠÙˆ", callback_data="type_video")
        ],
        [
            InlineKeyboardButton("ğŸµ Ù…ÙˆØ³ÙŠÙ‚Ù‰", callback_data="type_audio"),
            InlineKeyboardButton("ğŸ“Š Ù…Ø¹Ù„ÙˆÙ…Ø§Øª", callback_data="type_info")
        ],
        [
            InlineKeyboardButton("ğŸ” Ø¨Ø­Ø« Ø£ØºÙ†ÙŠØ©", callback_data="type_search")
        ]
    ]
    return InlineKeyboardMarkup(keyboard)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªØ±Ø­ÙŠØ¨ Ù…Ø¹ Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø§Ø®ØªÙŠØ§Ø±"""
    if not await check_subscription(update, context):
        await subscription_required(update, context)
        return
    
    # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    user = update.effective_user
    stats.add_user(user.id, user.full_name, user.username or "Ø¨Ø¯ÙˆÙ† Ù…Ø¹Ø±Ù")
    
    welcome_message = """ 

ğŸ‰ Ø£Ù‡Ù„Ø§Ù‹ ÙˆØ³Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¨ÙˆØª ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ù…Ù† Ù…ÙˆØ§Ù‚Ø¹ Ø§Ù„ØªÙˆØ§ØµÙ„ Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠ! ğŸ‘‹
Ù…Ø¹ Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª ÙŠÙ…ÙƒÙ†Ùƒ Ø¨Ø³Ù‡ÙˆÙ„Ø© ØªÙ†Ø²ÙŠÙ„ ÙƒÙ„ Ù…Ø§ ØªØ­ØªØ§Ø¬Ù‡ Ù…Ù† ØµÙˆØ±ØŒ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§ØªØŒ Ù…ÙˆØ³ÙŠÙ‚Ù‰ØŒ Ø¨Ø§Ù„Ø¥Ø¶Ø§ÙØ© Ø¥Ù„Ù‰ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø®Ø§ØµØ© Ø¨Ø§Ù„Ù…Ø­ØªÙˆÙ‰.

ğŸ“¥ Ù…Ø§ Ø§Ù„Ø°ÙŠ ÙŠÙ…ÙƒÙ†Ùƒ ØªØ­Ù…ÙŠÙ„Ù‡ØŸ

ğŸ¥ Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª
ğŸµ Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰
ğŸ–¼ Ø§Ù„ØµÙˆØ± (Ø³ÙŠØªÙ… ØªÙØ¹ÙŠÙ„Ù‡Ø§ Ù‚Ø±ÙŠØ¨Ù‹Ø§ Ø¨Ø¹Ø¯ Ø§Ù†ØªÙ‡Ø§Ø¡ Ø§Ù„ØµÙŠØ§Ù†Ø©)

ğŸŒ Ø§Ù„Ù…Ù†ØµØ§Øª Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©

YouTube â€“ Instagram â€“ TikTok â€“ Facebook â€“ Twitter/X â€“ Pinterest â€“ SoundCloud
ÙˆØ§Ù„Ù…Ø²ÙŠØ¯ Ù…Ù† Ø§Ù„Ù…Ù†ØµØ§Øª Ø§Ù„Ø£Ø®Ø±Ù‰!

ğŸ“ ÙƒÙŠÙÙŠØ© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…

1ï¸âƒ£ Ø£Ø±Ø³Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø£Ùˆ Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ù…Ø¨Ø§Ø´Ø±Ø© Ù„ÙŠØªÙ… ØªØ­Ù…ÙŠÙ„Ù‡Ø§
2ï¸âƒ£ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø§Ù…ÙˆØ§Ù…Ø±

/video [Ø±Ø§Ø¨Ø·] Ù„ØªØ­Ù…ÙŠÙ„ ÙÙŠØ¯ÙŠÙˆ

/audio [Ø±Ø§Ø¨Ø·] Ù„ØªØ­Ù…ÙŠÙ„ Ù…ÙˆØ³ÙŠÙ‚Ù‰ ÙÙ‚Ø·

/info [Ø±Ø§Ø¨Ø·] Ù„Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø­ØªÙˆÙ‰

/search [Ø§Ø³Ù… Ø§Ù„Ø£ØºÙ†ÙŠØ©] Ù„Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£ØºÙ†ÙŠØ©

ğŸ”— ØªÙ… ØªØ·ÙˆÙŠØ± Ø§Ù„Ø¨ÙˆØª Ø¨ÙˆØ§Ø³Ø·Ø© Ø¥Ø¯Ø§Ø±Ø© Ù‚Ù†Ø§Ø© Ø³Ø§Ø®Ø± | Ø¹Ø§Ù„Ù… Ø¨Ø±Ø´Ù„ÙˆÙ†Ø©

âœ¨ Ø§Ø³ØªÙ…ØªØ¹ Ø¨ØªØ¬Ø±Ø¨ØªÙƒ! ğŸ˜„

    """
    
    await update.message.reply_text(
        welcome_message,
        reply_markup=get_type_selection_keyboard()
    )

async def type_selection_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬ Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø±"""
    query = update.callback_query
    await query.answer()
    
    user_id = update.effective_user.id
    download_type = query.data.replace("type_", "")
    
    # Ø­ÙØ¸ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    user_states[user_id] = download_type
    
    type_emoji = {
        'image': 'ğŸ“¸',
        'video': 'ğŸ¬',
        'audio': 'ğŸµ',
        'info': 'ğŸ“Š',
        'search': 'ğŸ”'
    }
    
    type_name = {
        'image': 'ØµÙˆØ±Ø©',
        'video': 'ÙÙŠØ¯ÙŠÙˆ',
        'audio': 'Ù…ÙˆØ³ÙŠÙ‚Ù‰',
        'info': 'Ù…Ø¹Ù„ÙˆÙ…Ø§Øª',
        'search': 'Ø¨Ø­Ø« Ø£ØºÙ†ÙŠØ©'
    }
    
    if download_type == 'search':
        await query.message.edit_text(
            f"{type_emoji[download_type]} {type_name[download_type]}\n\n"
            f"Ø£Ø±Ø³Ù„ Ø§Ø³Ù… Ø§Ù„Ø£ØºÙ†ÙŠØ© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù†Ù‡Ø§...\n\n"
            f"Ù…Ø«Ø§Ù„: Imagine Dragons Believer\n\n"
            f"ğŸ’¡ Ø£Ùˆ Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø¢Ø®Ø±:",
            reply_markup=get_type_selection_keyboard()
        )
    else:
        await query.message.edit_text(
            f"{type_emoji[download_type]} ØªÙ… Ø§Ø®ØªÙŠØ§Ø±: {type_name[download_type]}\n\n"
            f"Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ø§Ù„Ø±Ø§Ø¨Ø·...\n\n"
            f"ğŸ’¡ Ø£Ùˆ Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø¢Ø®Ø±:",
            reply_markup=get_type_selection_keyboard()
        )

async def image_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ØªØ­Ù…ÙŠÙ„ ØµÙˆØ±Ø© Ù…Ø¨Ø§Ø´Ø±Ø©"""
    if not await check_subscription(update, context):
        await subscription_required(update, context)
        return
    
    if not context.args:
        await update.message.reply_text("âš ï¸ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø§Ø¨Ø· Ù…Ø¹ Ø§Ù„Ø£Ù…Ø±\nÙ…Ø«Ø§Ù„: /image https://instagram.com/...")
        return
    
    url = context.args[0]
    await download_image_handler(update, context, url)

async def video_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ØªØ­Ù…ÙŠÙ„ ÙÙŠØ¯ÙŠÙˆ Ù…Ø¨Ø§Ø´Ø±Ø©"""
    if not await check_subscription(update, context):
        await subscription_required(update, context)
        return
    
    if not context.args:
        await update.message.reply_text("âš ï¸ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø§Ø¨Ø· Ù…Ø¹ Ø§Ù„Ø£Ù…Ø±\nÙ…Ø«Ø§Ù„: /video https://tiktok.com/...")
        return
    
    url = context.args[0]
    await download_video_handler(update, context, url)

async def audio_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ØªØ­Ù…ÙŠÙ„ Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ù…Ø¨Ø§Ø´Ø±Ø©"""
    if not await check_subscription(update, context):
        await subscription_required(update, context)
        return
    
    if not context.args:
        await update.message.reply_text("âš ï¸ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø§Ø¨Ø· Ù…Ø¹ Ø§Ù„Ø£Ù…Ø±\nÙ…Ø«Ø§Ù„: /audio https://youtube.com/...")
        return
    
    url = context.args[0]
    message = await update.message.reply_text("ğŸµ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰...")
    
    try:
        filename, title = downloader.download_audio(url)
        
        await message.edit_text("ğŸ“¤ Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù...")
        
        with open(filename, 'rb') as audio_file:
            await update.message.reply_audio(
                audio=audio_file,
                title=title,
                caption=f"ğŸµ {title}"
            )
        
        os.remove(filename)
        await message.delete()
        
    except Exception as e:
        await message.edit_text(f"âŒ Ø®Ø·Ø£: {str(e)}")

async def info_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…ÙØµÙ„Ø©"""
    if not await check_subscription(update, context):
        await subscription_required(update, context)
        return
    
    if not context.args:
        await update.message.reply_text("âš ï¸ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø§Ø¨Ø· Ù…Ø¹ Ø§Ù„Ø£Ù…Ø±\nÙ…Ø«Ø§Ù„: /info https://youtube.com/...")
        return
    
    url = context.args[0]
    message = await update.message.reply_text("ğŸ” Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª...")
    
    try:
        info = downloader.get_info(url)
        
        if not info:
            await message.edit_text("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª")
            return
        
        title = info.get('title', info.get('webpage_title', 'ØºÙŠØ± Ù…ØªÙˆÙØ±'))
        uploader = info.get('uploader', info.get('channel', info.get('creator', 'ØºÙŠØ± Ù…ØªÙˆÙØ±')))
        duration = info.get('duration', 0)
        view_count = info.get('view_count', 0)
        like_count = info.get('like_count', 0)
        
        if duration and duration > 0:
            hours = duration // 3600
            minutes = (duration % 3600) // 60
            seconds = duration % 60
            if hours > 0:
                duration_str = f"{hours}:{minutes:02d}:{seconds:02d}"
            else:
                duration_str = f"{minutes}:{seconds:02d}"
        else:
            duration_str = "ØºÙŠØ± Ù…ØªÙˆÙØ±"
        
        view_str = f"{view_count:,}" if view_count else "ØºÙŠØ± Ù…ØªÙˆÙØ±"
        like_str = f"{like_count:,}" if like_count else "ØºÙŠØ± Ù…ØªÙˆÙØ±"
        
        info_text = f"""
ğŸ“Š Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø­ØªÙˆÙ‰:

ğŸ“Œ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†: {title}

ğŸ‘¤ Ø§Ù„Ù†Ø§Ø´Ø±: {uploader}

â±ï¸ Ø§Ù„Ù…Ø¯Ø©: {duration_str}

ğŸ‘ï¸ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª: {view_str}
â¤ï¸ Ø§Ù„Ø¥Ø¹Ø¬Ø§Ø¨Ø§Øª: {like_str}
        """
        
        await message.edit_text(info_text)
        
    except Exception as e:
        await message.edit_text(f"âŒ Ø®Ø·Ø£: {str(e)}")

async def search_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£ØºÙ†ÙŠØ© ÙÙŠ YouTube"""
    if not await check_subscription(update, context):
        await subscription_required(update, context)
        return
    
    if not context.args:
        await update.message.reply_text(
            "âš ï¸ Ø§Ù„Ø±Ø¬Ø§Ø¡ ÙƒØªØ§Ø¨Ø© Ø§Ø³Ù… Ø§Ù„Ø£ØºÙ†ÙŠØ© Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±\n"
            "Ù…Ø«Ø§Ù„: /search Imagine Dragons Believer"
        )
        return
    
    query = ' '.join(context.args)
    message = await update.message.reply_text(f"ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù†: {query}...")
    
    # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¨Ø­Ø«
    stats.add_search()
    
    try:
        results = downloader.search_youtube(query, max_results=5)
        
        if not results:
            await message.edit_text("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬")
            return
        
        # Ø­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
        user_id = update.effective_user.id
        search_results[user_id] = results
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø²Ø±Ø§Ø±
        keyboard = []
        for i, video in enumerate(results):
            duration = video['duration']
            if duration and duration > 0:
                minutes = int(duration) // 60
                seconds = int(duration) % 60
                duration_str = f"{minutes}:{seconds:02d}"
            else:
                duration_str = "?"
            
            button_text = f"ğŸµ {video['title'][:45]}... ({duration_str})"
            keyboard.append([InlineKeyboardButton(
                button_text, 
                callback_data=f"download_song_{i}"
            )])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await message.edit_text(
            f"ğŸµ Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù†: {query}\n\n"
            f"Ø§Ø®ØªØ± Ø§Ù„Ø£ØºÙ†ÙŠØ© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ ØªØ­Ù…ÙŠÙ„Ù‡Ø§:",
            reply_markup=reply_markup
        )
        
    except Exception as e:
        await message.edit_text(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø«: {str(e)}")
        logger.error(f"Ø®Ø·Ø£ ÙÙŠ search_command: {e}")

async def download_song_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£ØºÙ†ÙŠØ© Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©"""
    query = update.callback_query
    await query.answer()
    
    user_id = update.effective_user.id
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø«
    if user_id not in search_results:
        await query.message.edit_text("âŒ Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø¨Ø­Ø«. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø« Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")
        return
    
    # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø±Ù‚Ù… Ø§Ù„Ø£ØºÙ†ÙŠØ©
    try:
        song_index = int(query.data.split('_')[-1])
        video = search_results[user_id][song_index]
    except (IndexError, ValueError):
        await query.message.edit_text("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø£ØºÙ†ÙŠØ©")
        return
    
    await query.message.edit_text(f"ğŸµ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„: {video['title'][:50]}...")
    
    try:
        # ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£ØºÙ†ÙŠØ©
        filename, title = downloader.download_audio(video['url'])
        
        # ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ø§Ø¬Ø­
        stats.add_download('search')
        
        await query.message.edit_text("ğŸ“¤ Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£ØºÙ†ÙŠØ©...")
        
        # Ø¥Ø±Ø³Ø§Ù„ ÙƒÙ…Ù„Ù ØµÙˆØªÙŠ
        with open(filename, 'rb') as audio_file:
            await query.message.reply_audio(
                audio=audio_file,
                title=title,
                performer=video['channel'],
                caption=f"ğŸµ {title}\nğŸ‘¤ {video['channel']}"
            )
        
        # Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø¤Ù‚Øª
        os.remove(filename)
        await query.message.delete()
        
        # Ø­Ø°Ù Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø«
        if user_id in search_results:
            del search_results[user_id]
        
    except Exception as e:
        stats.add_failed_download()
        await query.message.edit_text(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„: {str(e)}")
        logger.error(f"Ø®Ø·Ø£ ÙÙŠ download_song_callback: {e}")
    """Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£ØºÙ†ÙŠØ© ÙÙŠ YouTube"""
    if not await check_subscription(update, context):
        await subscription_required(update, context)
        return
    
    if not context.args:
        await update.message.reply_text(
            "âš ï¸ Ø§Ù„Ø±Ø¬Ø§Ø¡ ÙƒØªØ§Ø¨Ø© Ø§Ø³Ù… Ø§Ù„Ø£ØºÙ†ÙŠØ© Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±\n"
            "Ù…Ø«Ø§Ù„: /search Imagine Dragons Believer"
        )
        return
    
    query = ' '.join(context.args)
    message = await update.message.reply_text(f"ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù†: {query}...")
    
    try:
        results = downloader.search_youtube(query, max_results=5)
        
        if not results:
            await message.edit_text("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬")
            return
        
        # Ø­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
        user_id = update.effective_user.id
        search_results[user_id] = results
        
        # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø²Ø±Ø§Ø±
        keyboard = []
        for i, video in enumerate(results):
            duration = video['duration']
            minutes = duration // 60
            seconds = duration % 60
            duration_str = f"{minutes}:{seconds:02d}" if duration else "?"
            
            button_text = f"ğŸµ {video['title'][:45]}... ({duration_str})"
            keyboard.append([InlineKeyboardButton(
                button_text, 
                callback_data=f"download_song_{i}"
            )])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await message.edit_text(
            f"ğŸµ Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù†: {query}\n\n"
            f"Ø§Ø®ØªØ± Ø§Ù„Ø£ØºÙ†ÙŠØ© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ ØªØ­Ù…ÙŠÙ„Ù‡Ø§:",
            reply_markup=reply_markup
        )
        
    except Exception as e:
        await message.edit_text(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø«: {str(e)}")
        logger.error(f"Ø®Ø·Ø£ ÙÙŠ search_command: {e}")

async def download_song_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£ØºÙ†ÙŠØ© Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©"""
    query = update.callback_query
    await query.answer()
    
    user_id = update.effective_user.id
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø«
    if user_id not in search_results:
        await query.message.edit_text("âŒ Ø§Ù†ØªÙ‡Øª ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø¨Ø­Ø«. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø¨Ø­Ø« Ù…Ø±Ø© Ø£Ø®Ø±Ù‰")
        return
    
    # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø±Ù‚Ù… Ø§Ù„Ø£ØºÙ†ÙŠØ©
    try:
        song_index = int(query.data.split('_')[-1])
        video = search_results[user_id][song_index]
    except (IndexError, ValueError):
        await query.message.edit_text("âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø£ØºÙ†ÙŠØ©")
        return
    
    await query.message.edit_text(f"ğŸµ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„: {video['title'][:50]}...")
    
    try:
        # ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø£ØºÙ†ÙŠØ©
        filename, title = downloader.download_audio(video['url'])
        
        await query.message.edit_text("ğŸ“¤ Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø£ØºÙ†ÙŠØ©...")
        
        # Ø¥Ø±Ø³Ø§Ù„ ÙƒÙ…Ù„Ù ØµÙˆØªÙŠ
        with open(filename, 'rb') as audio_file:
            await query.message.reply_audio(
                audio=audio_file,
                title=title,
                performer=video['channel'],
                caption=f"ğŸµ {title}\nğŸ‘¤ {video['channel']}"
            )
        
        # Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø¤Ù‚Øª
        os.remove(filename)
        await query.message.delete()
        
        # Ø­Ø°Ù Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø«
        if user_id in search_results:
            del search_results[user_id]
        
    except Exception as e:
        await query.message.edit_text(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù…ÙŠÙ„: {str(e)}")
        logger.error(f"Ø®Ø·Ø£ ÙÙŠ download_song_callback: {e}")
    """Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ù…ÙØµÙ„Ø©"""
    if not await check_subscription(update, context):
        await subscription_required(update, context)
        return
    
    if not context.args:
        await update.message.reply_text("âš ï¸ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø§Ø¨Ø· Ù…Ø¹ Ø§Ù„Ø£Ù…Ø±\nÙ…Ø«Ø§Ù„: /info https://youtube.com/...")
        return
    
    url = context.args[0]
    message = await update.message.reply_text("ğŸ” Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª...")
    
    try:
        info = downloader.get_info(url)
        
        if not info:
            await message.edit_text("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª")
            return
        
        title = info.get('title', info.get('webpage_title', 'ØºÙŠØ± Ù…ØªÙˆÙØ±'))
        uploader = info.get('uploader', info.get('channel', info.get('creator', 'ØºÙŠØ± Ù…ØªÙˆÙØ±')))
        duration = info.get('duration', 0)
        view_count = info.get('view_count', 0)
        like_count = info.get('like_count', 0)
        
        if duration and duration > 0:
            hours = duration // 3600
            minutes = (duration % 3600) // 60
            seconds = duration % 60
            if hours > 0:
                duration_str = f"{hours}:{minutes:02d}:{seconds:02d}"
            else:
                duration_str = f"{minutes}:{seconds:02d}"
        else:
            duration_str = "ØºÙŠØ± Ù…ØªÙˆÙØ±"
        
        view_str = f"{view_count:,}" if view_count else "ØºÙŠØ± Ù…ØªÙˆÙØ±"
        like_str = f"{like_count:,}" if like_count else "ØºÙŠØ± Ù…ØªÙˆÙØ±"
        
        info_text = f"""
ğŸ“Š Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø­ØªÙˆÙ‰:

ğŸ“Œ Ø§Ù„Ø¹Ù†ÙˆØ§Ù†: {title}

ğŸ‘¤ Ø§Ù„Ù†Ø§Ø´Ø±: {uploader}

â±ï¸ Ø§Ù„Ù…Ø¯Ø©: {duration_str}

ğŸ‘ï¸ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø§Øª: {view_str}
â¤ï¸ Ø§Ù„Ø¥Ø¹Ø¬Ø§Ø¨Ø§Øª: {like_str}
        """
        
        await message.edit_text(info_text)
        
    except Exception as e:
        await message.edit_text(f"âŒ Ø®Ø·Ø£: {str(e)}")

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¹Ø±Ø¶ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª (Ù„Ù„Ù…Ø·ÙˆØ± ÙÙ‚Ø·)"""
    user_id = update.effective_user.id
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù‡Ùˆ Ø§Ù„Ù…Ø·ÙˆØ±
    if user_id != DEVELOPER_ID:
        await update.message.reply_text("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…ØªØ§Ø­ Ù„Ù„Ù…Ø·ÙˆØ± ÙÙ‚Ø·")
        return
    
    stats_text = stats.get_stats_text()
    await update.message.reply_text(stats_text)

async def broadcast_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† (Ù„Ù„Ù…Ø·ÙˆØ± ÙÙ‚Ø·)"""
    user_id = update.effective_user.id
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù‡Ùˆ Ø§Ù„Ù…Ø·ÙˆØ±
    if user_id != DEVELOPER_ID:
        await update.message.reply_text("â›” Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…ØªØ§Ø­ Ù„Ù„Ù…Ø·ÙˆØ± ÙÙ‚Ø·")
        return
    
    if not context.args:
        await update.message.reply_text(
            "âš ï¸ Ø§Ù„Ø±Ø¬Ø§Ø¡ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¨Ø¹Ø¯ Ø§Ù„Ø£Ù…Ø±\n"
            "Ù…Ø«Ø§Ù„: /broadcast Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ø§Ù„Ø¬Ù…ÙŠØ¹!"
        )
        return
    
    broadcast_text = ' '.join(context.args)
    message = await update.message.reply_text("ğŸ“¤ Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©...")
    
    success_count = 0
    fail_count = 0
    
    for user_id_str in stats.data['users'].keys():
        try:
            await context.bot.send_message(
                chat_id=int(user_id_str),
                text=f"ğŸ“¢ Ø±Ø³Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ù…Ø·ÙˆØ±:\n\n{broadcast_text}"
            )
            success_count += 1
        except Exception as e:
            fail_count += 1
            logger.error(f"ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ {user_id_str}: {e}")
    
    await message.edit_text(
        f"âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©\n\n"
        f"âœ… Ù†Ø¬Ø­: {success_count}\n"
        f"âŒ ÙØ´Ù„: {fail_count}"
    )
    """Ù…Ø¹Ø§Ù„Ø¬ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±"""
    message = await update.message.reply_text("ğŸ“¸ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©...")
    
    filename = None
    try:
        logger.info(f"=== Ø¨Ø¯Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø© ===")
        logger.info(f"Ø§Ù„Ø±Ø§Ø¨Ø·: {url}")
        
        filename, title = downloader.download_image(url)
        
        logger.info(f"Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù: {filename}")
        logger.info(f"Ù‡Ù„ Ø§Ù„Ù…Ù„Ù Ù…ÙˆØ¬ÙˆØ¯: {os.path.exists(filename)}")
        
        if not os.path.exists(filename):
            await message.edit_text("âŒ Ø§Ù„Ù…Ù„Ù ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯")
            return
        
        file_size = os.path.getsize(filename)
        logger.info(f"Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù: {file_size} Ø¨Ø§ÙŠØª ({file_size / (1024*1024):.2f} MB)")
        
        if file_size == 0:
            await message.edit_text("âŒ Ø§Ù„Ù…Ù„Ù ÙØ§Ø±Øº")
            os.remove(filename)
            return
        
        if file_size > 10 * 1024 * 1024:
            await message.edit_text(f"âš ï¸ Ø§Ù„ØµÙˆØ±Ø© ÙƒØ¨ÙŠØ±Ø© Ø¬Ø¯Ø§Ù‹ ({file_size // (1024*1024)} MB)")
            os.remove(filename)
            return
        
        # Ù‚Ø±Ø§Ø¡Ø© Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ù„Ù
        logger.info("Ù‚Ø±Ø§Ø¡Ø© Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ù„Ù...")
        with open(filename, 'rb') as f:
            file_content = f.read()
        
        logger.info(f"ØªÙ… Ù‚Ø±Ø§Ø¡Ø© {len(file_content)} Ø¨Ø§ÙŠØª")
        
        if len(file_content) == 0:
            await message.edit_text("âŒ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ù…Ù„Ù ÙØ§Ø±Øº")
            os.remove(filename)
            return
        
        # Ø¹Ø±Ø¶ Ø£ÙˆÙ„ 20 Ø¨Ø§ÙŠØª Ù„Ù„ØªØ´Ø®ÙŠØµ
        logger.info(f"Ø£ÙˆÙ„ 20 Ø¨Ø§ÙŠØª: {file_content[:20]}")
        
        await message.edit_text("ğŸ“¤ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„...")
        
        # Ù…Ø­Ø§ÙˆÙ„Ø© Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ø¨Ø·Ø±ÙŠÙ‚Ø© Ù…Ø¨Ø§Ø´Ø±Ø©
        try:
            # Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© 1: Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¨Ø§Ø´Ø± Ù…Ù† Ø§Ù„Ù…Ø³Ø§Ø±
            logger.info("Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±...")
            await update.message.reply_photo(
                photo=open(filename, 'rb'),
                caption=f"ğŸ“¸ {title[:200]}"
            )
            logger.info("âœ… Ù†Ø¬Ø­ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±")
            await message.delete()
            
        except Exception as e1:
            logger.error(f"ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±: {e1}")
            
            # Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© 2: Ø¥Ø±Ø³Ø§Ù„ Ù…Ù† BytesIO
            try:
                logger.info("Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ù…Ù† BytesIO...")
                from io import BytesIO
                photo_bytes = BytesIO(file_content)
                photo_bytes.name = f"image.{filename.split('.')[-1]}"
                
                await update.message.reply_photo(
                    photo=photo_bytes,
                    caption=f"ğŸ“¸ {title[:200]}"
                )
                logger.info("âœ… Ù†Ø¬Ø­ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ù…Ù† BytesIO")
                await message.delete()
                
            except Exception as e2:
                logger.error(f"ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ù…Ù† BytesIO: {e2}")
                
                # Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© 3: Ø¥Ø±Ø³Ø§Ù„ ÙƒÙ€ Document
                try:
                    logger.info("Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ ÙƒÙ€ Document...")
                    doc_bytes = BytesIO(file_content)
                    doc_bytes.name = os.path.basename(filename)
                    
                    await update.message.reply_document(
                        document=doc_bytes,
                        caption=f"ğŸ“¸ {title[:200]}"
                    )
                    logger.info("âœ… Ù†Ø¬Ø­ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ ÙƒÙ€ Document")
                    await message.delete()
                    
                except Exception as e3:
                    logger.error(f"ÙØ´Ù„Øª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø·Ø±Ù‚: {e3}")
                    await message.edit_text(
                        f"âŒ ÙØ´Ù„ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„\n"
                        f"Ø§Ù„Ø­Ø¬Ù…: {file_size / 1024:.1f} KB\n"
                        f"Ø§Ù„Ø®Ø·Ø£: {str(e3)[:100]}"
                    )
                    return
        
        # Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù Ø¨Ø¹Ø¯ Ø§Ù„Ù†Ø¬Ø§Ø­
        try:
            if os.path.exists(filename):
                os.remove(filename)
                logger.info("ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù")
        except Exception as del_err:
            logger.warning(f"ÙØ´Ù„ Ø­Ø°Ù Ø§Ù„Ù…Ù„Ù: {del_err}")
        
    except Exception as e:
        error_msg = f"âŒ Ø®Ø·Ø£: {str(e)[:200]}"
        await message.edit_text(error_msg)
        logger.error(f"=== Ø®Ø·Ø£ Ø¹Ø§Ù… ===")
        logger.error(f"{type(e).__name__}: {str(e)}")
        import traceback
        logger.error(traceback.format_exc())
        
        # ØªÙ†Ø¸ÙŠÙ
        if filename and os.path.exists(filename):
            try:
                os.remove(filename)
            except:
                pass

async def download_video_handler(update: Update, context: ContextTypes.DEFAULT_TYPE, url: str):
    """Ù…Ø¹Ø§Ù„Ø¬ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª"""
    message = await update.message.reply_text("ğŸ¬ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ...")
    
    try:
        filename, title = downloader.download_video(url)
        
        file_size = os.path.getsize(filename)
        max_size = 50 * 1024 * 1024
        
        if file_size > max_size:
            stats.add_failed_download()
            await message.edit_text(
                f"âš ï¸ Ø§Ù„Ù…Ù„Ù ÙƒØ¨ÙŠØ± Ø¬Ø¯Ø§Ù‹ ({file_size // (1024*1024)} MB)\n"
                f"Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰: 50 MB\n\n"
                f"ğŸ’¡ Ø¬Ø±Ø¨: /audio {url}"
            )
            os.remove(filename)
            return
        
        await message.edit_text("ğŸ“¤ Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ...")
        
        with open(filename, 'rb') as video:
            await update.message.reply_video(
                video=video,
                caption=f"ğŸ¬ {title}",
                supports_streaming=True
            )
        
        stats.add_download('video')
        os.remove(filename)
        await message.delete()
        
    except Exception as e:
        stats.add_failed_download()
        await message.edit_text(f"âŒ Ø®Ø·Ø£: {str(e)}")

async def handle_url(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø£Ùˆ Ø§Ù„Ø¨Ø­Ø« Ø­Ø³Ø¨ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
    if not await check_subscription(update, context):
        await subscription_required(update, context)
        return
    
    text = update.message.text
    user_id = update.effective_user.id
    
    # Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ÙÙŠ ÙˆØ¶Ø¹ Ø§Ù„Ø¨Ø­Ø«
    if user_id in user_states and user_states[user_id] == 'search':
        # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø£ØºÙ†ÙŠØ©
        message = await update.message.reply_text(f"ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù†: {text}...")
        
        try:
            results = downloader.search_youtube(text, max_results=5)
            
            if not results:
                await message.edit_text("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬")
                return
            
            # Ø­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬
            search_results[user_id] = results
            
            # Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø£Ø²Ø±Ø§Ø±
            keyboard = []
            for i, video in enumerate(results):
                duration = video['duration']
                if duration and duration > 0:
                    minutes = int(duration) // 60
                    seconds = int(duration) % 60
                    duration_str = f"{minutes}:{seconds:02d}"
                else:
                    duration_str = "?"
                
                button_text = f"ğŸµ {video['title'][:45]}... ({duration_str})"
                keyboard.append([InlineKeyboardButton(
                    button_text, 
                    callback_data=f"download_song_{i}"
                )])
            
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await message.edit_text(
                f"ğŸµ Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù†: {text}\n\n"
                f"Ø§Ø®ØªØ± Ø§Ù„Ø£ØºÙ†ÙŠØ© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ ØªØ­Ù…ÙŠÙ„Ù‡Ø§:",
                reply_markup=reply_markup
            )
            
        except Exception as e:
            await message.edit_text(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø«: {str(e)}")
            logger.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø«: {e}")
        
        return
    
    # Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ø¹Ø§Ø¯ÙŠØ©
    if not text.startswith(('http://', 'https://')):
        return
    
    # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    if user_id not in user_states:
        await update.message.reply_text(
            "âš ï¸ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù†ÙˆØ¹ Ø§Ù„Ù…Ø­ØªÙˆÙ‰ Ø£ÙˆÙ„Ø§Ù‹:\n\n"
            "Ø§Ø³ØªØ®Ø¯Ù… /start Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª",
            reply_markup=get_type_selection_keyboard()
        )
        return
    
    download_type = user_states[user_id]
    
    # ØªÙ†ÙÙŠØ° Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„Ù…Ø®ØªØ§Ø±
    if download_type == 'image':
        await download_image_handler(update, context, text)
    elif download_type == 'video':
        await download_video_handler(update, context, text)
    elif download_type == 'audio':
        message = await update.message.reply_text("ğŸµ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰...")
        try:
            filename, title = downloader.download_audio(text)
            await message.edit_text("ğŸ“¤ Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…Ù„Ù...")
            
            with open(filename, 'rb') as audio_file:
                await update.message.reply_audio(
                    audio=audio_file,
                    title=title,
                    caption=f"ğŸµ {title}"
                )
            
            stats.add_download('audio')
            os.remove(filename)
            await message.delete()
        except Exception as e:
            stats.add_failed_download()
            await message.edit_text(f"âŒ Ø®Ø·Ø£: {str(e)}")
    elif download_type == 'info':
        await info_command(update, context)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©"""
    if not await check_subscription(update, context):
        await subscription_required(update, context)
        return
    
    help_text = """
ğŸ“š Ø¯Ù„ÙŠÙ„ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¨ÙˆØª:

ğŸ¯ Ø·Ø±ÙŠÙ‚ØªØ§Ù† Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…:

1ï¸âƒ£ Ø§Ù„Ø£Ø²Ø±Ø§Ø± (Ø³Ù‡Ù„Ø©):
â€¢ Ø£Ø±Ø³Ù„ /start
â€¢ Ø§Ø®ØªØ± Ù†ÙˆØ¹ Ø§Ù„Ù…Ø­ØªÙˆÙ‰
â€¢ Ø£Ø±Ø³Ù„ Ø§Ù„Ø±Ø§Ø¨Ø· Ø£Ùˆ Ø§Ø³Ù… Ø§Ù„Ø£ØºÙ†ÙŠØ©

2ï¸âƒ£ Ø§Ù„Ø£ÙˆØ§Ù…Ø± (Ø³Ø±ÙŠØ¹Ø©):
/video [Ø±Ø§Ø¨Ø·] - ÙÙŠØ¯ÙŠÙˆ
/audio [Ø±Ø§Ø¨Ø·] - Ù…ÙˆØ³ÙŠÙ‚Ù‰
/info [Ø±Ø§Ø¨Ø·] - Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
/search [Ø§Ø³Ù… Ø§Ù„Ø£ØºÙ†ÙŠØ©] - Ø¨Ø­Ø« Ø£ØºÙ†ÙŠØ©

ğŸµ Ù…ÙŠØ²Ø© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø£ØºØ§Ù†ÙŠ:
â€¢ Ø§Ø¶ØºØ· Ø²Ø± "ğŸ” Ø¨Ø­Ø« Ø£ØºÙ†ÙŠØ©"
â€¢ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù…: /search Believer
â€¢ Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ù†ØªØ§Ø¦Ø¬
â€¢ Ø§Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø£ØºÙ†ÙŠØ© Ù…Ø¨Ø§Ø´Ø±Ø©!

ğŸ“± Ø§Ù„Ù…Ù†ØµØ§Øª Ø§Ù„Ù…Ø¯Ø¹ÙˆÙ…Ø©:
Instagram, TikTok, YouTube, Twitter, Facebook, Pinterest, SoundCloud

ğŸ’¡ Ù†ØµØ§Ø¦Ø­:
â€¢ Ø§Ø®ØªØ± Ø§Ù„Ù†ÙˆØ¹ Ø§Ù„ØµØ­ÙŠØ­ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø©
â€¢ Ù„Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ø§Ù„ÙƒØ¨ÙŠØ±Ø© (+50MB)ØŒ Ø§Ø³ØªØ®Ø¯Ù… /audio
â€¢ Ø§Ù„Ø¨Ø­Ø« ÙŠØ¹Ù…Ù„ Ù…Ø¹ Ø¬Ù…ÙŠØ¹ Ø£ØºØ§Ù†ÙŠ YouTube
    """
    
    await update.message.reply_text(help_text)

def main():
    """ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª"""
    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
    
    # Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£Ø²Ø±Ø§Ø±
    application.add_handler(CallbackQueryHandler(check_subscription_callback, pattern="check_subscription"))
    application.add_handler(CallbackQueryHandler(type_selection_callback, pattern="^type_"))
    application.add_handler(CallbackQueryHandler(download_song_callback, pattern="^download_song_"))
    
    # Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£ÙˆØ§Ù…Ø±
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("image", image_command))
    application.add_handler(CommandHandler("video", video_command))
    application.add_handler(CommandHandler("audio", audio_command))
    application.add_handler(CommandHandler("info", info_command))
    application.add_handler(CommandHandler("search", search_command))
    
    # Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…Ø·ÙˆØ±
    application.add_handler(CommandHandler("stats", stats_command))
    application.add_handler(CommandHandler("broadcast", broadcast_command))
    
    # Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø±ÙˆØ§Ø¨Ø· ÙˆØ§Ù„Ù†ØµÙˆØµ
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_url))
    
    logger.info("ğŸš€ Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù†...")
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()